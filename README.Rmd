---
title: Multiple Myeloma Dataset Comparison
author: V. Keith Hughitt
date: "`r format(Sys.time(), '%d %B, %Y') `"
output:
  html_document:
    toc: true
    number_sections: true
---

# TODO

1. Generate "thumbnail" overview images of each dataset.
2. Collapse multi-mapped probes prior to performing gene set enrichment (create
   duplicate rows for each gene symbol?..)

- Annotate datasets?
  - Are there any obvious factors that could explain why some datasets are more similar
    to others?
  - disease stage (MGUS vs. MM)
  - cell line vs. patient
  - dataset size
  - response measure type
  - platform
- Visualize some examples at each step? (e.g. compare count distributions for a single
  gene with high dip test?)
- Measure pathway GSEA enrichment for suvival results!


# IDEAS

1. For final gene weights, use mostly survival, etc. R^2's since these are likely to be
   the genes that are particularly important for MM.
2. For variance, etc. could try downloading a large number of "normal" (non-MM /
   non-cancer) samples and measure the same statistics. Then look for genes which have
   the highest variance in the MM samples, relative to healthy ones?
3. Use RCellMiner, etc. to select drugs with various mechanisms and generate
   gene weights targetted at each different type of drug mechanism?
   
# Overview

...

**Related work:**

1. [Botta et al. (2016)](https://www.nature.com/articles/bcj2016118) - Combines data
   from 5 different MM experiments (table S1) to determine a survival-specific gene signature.
   - focussed on inflammation-related gene subset.

```{r, message = FALSE}
library(annotables)
library(DataExplorer)
library(diptest)
library(e1071)
library(GSEABase)
library(fgsea)
library(heatmaply)
library(inspectdf)
library(knitr)
library(parallel)
library(samr)
library(silvermantest)
library(survival)
library(tidyverse)
```

```{r child='rmd/setup.Rmd'}
```

```{r rmarkdown_settings, include = FALSE}
# stop on encountered an error in a child rmd file
opts_chunk$set(error = FALSE)
opts_knit$set(verbose = TRUE)
```

```{r settings}
# maximum ratio of covariate variables to allow before exluding a gene
# from the final score computation
GENE_MAX_MISSING_COVARIATES <- 0.25
```

```{r initialize_cluster}
# create paralellization handler
cl <- makeCluster(MAX_THREADS, outfile='')
```

```{r load_gene_sets}
annot_dir <- '/data/annotations'

#msigdb_files  <- sprintf('%s.all.v6.2.symbols.gmt', c('h', 'c2', 'c5', 'c6', 'c7'))
#enrichr_files <- c('LINCS_L1000_Ligand_Perturbations_down.txt',
#                   'Kinase_Perturbations_from_GEO_up.txt', 'DSigDB.txt',
#                   'OMIM_Disease.txt')

bader_files   <- Sys.glob(file.path(annot_dir, 'bader_gene_sets', '*.gmt')) 
dsigdb_files  <- file.path(annot_dir, 'dsigdb', '1.0', 'DSigDB_All.gmt')
enrichr_files <- Sys.glob(file.path(annot_dir, 'enrichr', '*.txt'))
gdsc_files    <- Sys.glob(file.path(annot_dir, 'gdsc_drug_modules', '*-nr.gmt'))
msigdb_files  <- file.path(annot_dir, 'msigdb', 'v6.2', 'msigdb.v6.2.symbols.gmt')

gene_set_files <- c(bader_files, dsigdb_files, enrichr_files, gdsc_files, msigdb_files)

gene_sets <- lapply(gene_set_files, function(x) { geneIds(getGmt(x)) })

names(gene_sets) <- tools::file_path_sans_ext(basename(gene_set_files)) 
```

## Process datasets


```{r child='rmd/load_geo.Rmd'}
```

```{r child='rmd/load_mmrf.Rmd'}
```

## Results


```{r dataset_summary, results = 'asis')
# store dataset dimensions
outfile <- file.path(output_dir, 'dataset_dimensions.csv')

if (!file.exists(outfile)) {
	dataset_dimensions <- data.frame(acc = accessions, num_rows = dataset_num_rows, 
																	 num_cols = dataset_num_cols)
	write_csv(dataset_dimensions, outfile)
} else {
	dataset_dimensions <- read_csv(outfile)
}

cat(sprintf('- # datasets: %d\n', length(accessions)))
cat(sprintf('- # genes: %d\n', sum(dataset_dimensions$num_rows)))
cat(sprintf('- # samples: %d\n', sum(dataset_dimensions$num_cols)))
```

```{r results, message = FALSE}
# create variables to store result matrices
dat <- NULL

# load GEO, etc. datasets
for (dataset in Sys.glob('output/gene_weights_*')) {
  # load gene expression data
  gene_weights <- read_csv(dataset)

  # add to combined dataset
  if (is.null(dat)) {
    dat <- gene_weights
  } else {
    if ('ensgene' %in% colnames(dat) && 'ensgene' %in% colnames(gene_weights)) {
      gene_weights <- gene_weights %>%
        select(-ensgene)
    }
    dat <- dat %>%
      full_join(gene_weights, by = 'gene_symbol')
  }
}

#table(duplicated(dat$gene_symbol))
# 
# FALSE 
# 62114 

# drop any entries with no associated gene symbols
dat <- dat %>%
  filter(!is.na(gene_symbol))

# dups <- dat$gene_symbol[duplicated(dat$gene_symbol)]
#length(dups)
# [1] 0

#head(dups)
# [1] "5S_rRNA" "5S_rRNA" "5S_rRNA" "5S_rRNA" "5S_rRNA" "5S_rRNA"

# aggregate any remaining duplicated gene entries, as before
gene_stats <- dat %>%
	select(-matches('_pval$')) %>%
	group_by(gene_symbol) %>%
	summarize_all(max) %>%
	ungroup

gene_pvals <- dat %>%
	select(gene_symbol, matches('_pval$')) %>%
	group_by(gene_symbol) %>%
	summarize_all(min) %>%
	ungroup %>%
	select(-gene_symbol)

dat <- cbind(gene_stats, gene_pvals)

# reorder columns
id_cols <- c('gene_symbol', 'ensgene')
dat <- dat[, c(id_cols, colnames(dat)[!colnames(dat) %in% id_cols])]

# save combined gene weight data
write_csv(dat, 'output/combined_gene_weights.csv')
```

### Gene Weights Overview

```{r}
inspect_types(dat)
```

#### Dataset similarity

```{r}
#dat_long <- dat %>%
#  select(-ensgene) %>%
#  gather(key = gene_stat, value, -gene_symbol) %>%
#  mutate(dataset = str_extract(gene_stat, '[[:alnum:]]+'))

#table(dat_long$dataset)
#
#  GSE6477 GSE68871 GSE83503  GSE9782     mmrf
#   534789   415947   475368   950736   475368

#x <- dat_long %>%
#  spread(key = dataset, value = value)
```

##### By gene variance

```{r}
var_dat <- dat %>%
  select(matches('_variance_?\\d*$'))

var_cor_mat <- cor(var_dat, use = 'pairwise.complete.obs')

heatmaply(var_cor_mat)

# number of genes for which both GSE6477 and GSE9782
#var_high_cor <- var_dat %>%
#  select(GSE6477_variance, GSE9782_variance)

#table(apply(var_high_cor, 1, function(x) { sum(is.na(x)) == 0 }))
# 
# FALSE  TRUE 
# 57587  4527 
```

##### By gene mad

```{r}
mad_dat <- dat %>%
  select(matches('_mad_?\\d*$'))

mad_cor_mat <- cor(mad_dat, use = 'pairwise.complete.obs')

heatmaply(mad_cor_mat)
```

##### By gene dip statistic

```{r}
dip_dat <- dat %>%
  select(matches('_dip_stat_?\\d*$'))

dip_cor_mat <- cor(dip_dat, use = 'pairwise.complete.obs')

heatmaply(dip_cor_mat)
```

##### By covariate weights

```{r}
covariate_dat <- dat %>%
  select(-gene_symbol, -ensgene, -matches('_variance_?\\d*$'),
         -matches('mad_?\\d*$'), -matches('kurtosis_?\\d*$'),
         -matches('dip_stat_?\\d*$'), -matches('dip_pval_?\\d*$'),
         -matches('silv_stat_?\\d*$'), -matches('silv_pval_?\\d*$'))

rownames(covariate_dat) <- dat$gene_symbol

# number of missing entries for each gene
gene_num_na <- apply(covariate_dat, 1, function(x) { sum(is.na(x)) })

#table(gene_num_na)
# gene_num_na
#     0     1     2     3     4     5     6     7     8     9    10    11    12    13    14    15 
#  5465   206   176  6250   571   672  2676   369   810   834   910   526   335  1604    38   168 
#    16    17    18    19    20    21    22    23    24    25    26    27    28 
#   106  1192    52     8    93   578   442   954 19075  1702 14054   977   632 

max_na <- ceiling(GENE_MAX_MISSING_COVARIATES * ncol(covariate_dat))
covariate_dat <- covariate_dat[gene_num_na <= max_na, ]

covariate_cor_mat <- round(cor(covariate_dat, use = 'pairwise.complete.obs'), 2)

heatmaply(covariate_cor_mat, draw_cellnote = TRUE, cellnote_size = 8)
```


#### Missing data

```{r, fig.height = 16}
plot_missing(dat, ggtheme = theme_bw())
```

#### Data distributions

```{r fig.width = 6, fig.height = 6}
plot_density(dat, ggtheme = theme_bw_high_res(), parallel = TRUE)
```

#### Dataset / Gene Weight Measure Similarity

```{r, fig.width = 6, fig.height = 4.8}
theme_conf <- theme(axis.text.x = element_text(angle = 90, size = 3, hjust = 1),
                    axis.text.y = element_text(size = 3))
plot_correlation(dat, type = 'continuous', ggtheme = theme_bw_high_res(),
                 cor_args = list(use = 'pairwise.complete.obs'), theme_config =
                   theme_conf)
```

### Most informative genes

#### Using covariate gene weights only

```{r, fig.width = 6, fig.height = 6}
# convert p-values to -log10(pvalue) scores so that directionality is the same for
# all variables
covariate_dat_log10pvals <- covariate_dat %>%
  mutate_at(vars(matches("_pval_?\\d*$")), function (x) { -log10(x) }) %>%
  mutate_each(list(scale))

rownames(covariate_dat_log10pvals) <- rownames(covariate_dat)

#
# standardize? or max-scale?..
#
# standardizing will result in each variable contributing more equally to the final
# weights
#

# shift to right so that lowest value for each column is zero
for (x in colnames(covariate_dat_log10pvals)) {
  covariate_dat_log10pvals[, x] <- covariate_dat_log10pvals[, x] - min(covariate_dat_log10pvals[, x], na.rm = TRUE)
}

plot_density(covariate_dat_log10pvals, ggtheme = theme_bw_high_res(), parallel = TRUE)

# next compute average weights for each gene;
# note that some genes are only measured in one or a few of the datasets, so confidence
# of the gene weights should be considered

# how much each column contributes to the score..
#range(colMeans(covariate_dat_log10pvals, na.rm = TRUE))
# [1] 0.603 1.622

# get dataset names from column names;
# TODO: track explicitly..
#dset_names <- apply(str_split(colnames(covariate_dat_log10pvals), '_', 
#                              simplify = TRUE)[, 1:2], 1, paste, collapse='_')
# covariate_dat_log10pvals %*% diag(wts)
 
xx <- rowMeans(covariate_dat_log10pvals, na.rm = TRUE)
yy <- apply(covariate_dat_log10pvals, 1, median, na.rm = TRUE)

xxx <- head(sort(xx, decreasing = TRUE), 15)
yyy <- head(sort(yy, decreasing = TRUE), 15)

covariate_dat_log10pvals[names(xxx), ]

# top 20 genes
kable(head(sort(rowMeans(covariate_dat_log10pvals, na.rm = TRUE), decreasing = TRUE), 20))
```

```{r}
stopCluster(cl)
```

```{r fgsea, results = 'asis'}
for (gs in names(gene_sets)) {
	res <- fgsea(gene_sets[[gs]], xx, nperm = 10000, nproc = MAX_THREADS) %>%
		filter(padj < 0.05) %>%
		select(-leadingEdge) %>%
		arrange(padj)

	if (nrow(res) > 0) {
    cat(sprintf("\n##### %s\n", gs))
	  print(kable(head(res, 20)))
	}
}
```

```{r}
sessionInfo()
```

