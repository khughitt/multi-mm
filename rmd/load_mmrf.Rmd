## Load MMRF CoMMpass data

```{r process_mmrf_commpass_data}
# mmrf gene weights output filepath
gene_expr_path    <- file.path(mmrf_dir, 'rnaseq/MMRF_CoMMpass_IA13a_E74GTF_HtSeq_Gene_Counts.txt.gz')
pathway_expr_path <- file.path(mmrf_dir, 'rnaseq/MMRF_CoMMpass_IA13a_E74GTF_HtSeq_Pathway_Counts.txt.gz')

gene_weights_path    <- file.path(output_dir, 'gene_weights_mmrf.csv')
pathway_weights_path <- file.path(output_dir, 'pathway_weights_mmrf.csv')
fgsea_path           <- file.path(output_dir, 'fgsea_results_mmrf.csv')

weights_avail <- all(file.exists(gene_weights_path, pathway_weights_path))
```

```{r load_mmrf_data}
# load patient gene expression data
mmrf_raw_counts <- read_tsv(gene_expr_path)

# drop non-tumor samples;
mask <- substr(colnames(mmrf_raw_counts), 13, 14) == 'BM'

# first entry is mask corresponds to the patient id column which we always keep
mask[1] <- TRUE
mmrf_raw_counts <- mmrf_raw_counts[, mask]

# remove patients who dropped out?..

# for now, limit ourselves to baseline samples so that we have a single sample collected at the
# same relative stage for each patient
mask <- substr(colnames(mmrf_raw_counts), 11, 14) == '1_BM'
mask[1] <- TRUE

mmrf_raw_counts <- mmrf_raw_counts[, mask]
colnames(mmrf_raw_counts) <- substr(colnames(mmrf_raw_counts), 1, 9)

# drop rna-seq samples with no corresponding sample metadata (lose about 10%
# of patients here who dropped out of the study)
#mask <- substring(colnames(mmrf_raw_counts), 1, 9) %in% mmrf_surv$public_id
#message(sprintf("Excluding %d/%d patient RNA-Seq samples who dropped from study, or are missing metadata", sum(!mask), ncol(mmrf_raw_counts)))
#mmrf_raw_counts <- mmrf_raw_counts[, mask]

# drop "ERCC" rows (92 / 57997 genes)
mask <- !startsWith(mmrf_raw_counts$GENE_ID, 'ERCC')
mmrf_raw_counts <- mmrf_raw_counts[mask, ]

# drop genes with zero variance
mask <- apply(as.matrix(mmrf_raw_counts[, -1]), 1, var) > 0

#table(mask)
# mask
# FALSE  TRUE 
#  2817 55088 

mmrf_raw_counts <- mmrf_raw_counts[mask, ]

# create a cpm-normalized version of the raw counts
mmrf_gene_expr <- mmrf_raw_counts
mmrf_col_sums <- colSums(mmrf_gene_expr[, 2:ncol(mmrf_gene_expr)])
mmrf_gene_expr[, 2:ncol(mmrf_gene_expr)] <- sweep(mmrf_gene_expr[, 2:ncol(mmrf_gene_expr)],
                                                    2, mmrf_col_sums, '/') * 1E6
```

```{r create_pathway_aggregated_counts}
if (!file.exists(pathway_expr_path)) {
  pathway_expr <- NULL
  pathway_names <- c()

  message("Measuring pathway expression for MMRF...")

  # TODO: parallelize (slow..)

  # convert ENSEMBL ids to gene symbols
  gene_expr <- mmrf_gene_expr
  gene_expr$GENE_ID <- grch37$symbol[match(gene_expr$GENE_ID, grch37$ensgene)]

  # collapse multi-mapped gene symbols
  gene_expr <- gene_expr %>%
    group_by(GENE_ID) %>%
    summarize_all(sum) %>%
    ungroup

  for (collection in names(gene_sets)) {
    for (gset in names(gene_sets[[collection]])) {
      dat_gset <- gene_expr %>%
        filter(GENE_ID %in% gene_sets[[collection]][[gset]])

      # if no genes from gene set were found, continue to next gene set
      if (nrow(dat_gset) == 0) {
        next
      }
      pathway_names <- c(pathway_names, gset)

      # add pathway-level expression data
      pathway_expr <- rbind(pathway_expr, apply(dat_gset[, -1], 2, median, na.rm = TRUE))
    }
  }

  # drop any rows with zero variance (uninformative)
  mask <- apply(pathway_expr, 1, var, na.rm = TRUE) > 0
  pathway_expr <- pathway_expr[mask, ]
  pathway_names <- pathway_names[mask]

  pathway_expr <- bind_cols(gene_set = pathway_names, as.data.frame(pathway_expr))

  write_csv(pathway_expr, pathway_expr_path)
} else {
  # if pathway-level expression data exists, load from file
  pathway_expr <- read_csv(pathway_expr_path, col_types = cols())
}
```

#### MMRF CoMMpass Clinical Variables

```{r load_mmrf_patient_clinical_metadata, eval = !weights_avail}
# load patient clinical metadata
mmrf_clin <- read_csv(file.path(mmrf_dir, 'clinical_data_tables',
                                'MMRF_CoMMpass_IA13_PER_PATIENT.csv'))

mmrf_clin <- mmrf_clin %>%
  select(public_id = PUBLIC_ID, iss_stage = R_ISS, ecog, mm_status = D_PT_mmstatus)

# limit metadata to those patients for which gene expression data is present and match
# orders
mmrf_clin <- mmrf_clin[match(colnames(mmrf_raw_counts)[-1], mmrf_clin$public_id), ]

#all(mmrf_clin$public_id == colnames(mmrf_raw_counts)[-1])
# [1] TRUE

# initialize result variable; creates a dataframe with only the gene identifiers
gene_weights <- data.frame(ensgene = mmrf_gene_expr$GENE_ID)
pathway_weights <- pathway_expr[, 1, drop = FALSE]

output_cols <- c()

for (covariate in c('iss_stage', 'ecog', 'mm_status')) {
  message(sprintf("Processing MMRF-IA13 / %s", covariate))

  # get covariate column
  response <- mmrf_clin[, covariate, drop = TRUE]

  # column name to use in output
  output_colname <- make.names(sprintf("mmrf_%s", covariate))
  output_cols <- c(output_cols, output_colname)

  # for factor columns, compute R^2 for a logit predicting the factor level
  if (is.character(response) || length(unique(response)) < 10) {
    response <- factor(response)

    # multinomial logistic regression
    null <- glm(response ~ 1, family = "binomial")

    clusterExport(cl, c('response', 'null'))

    gene_weight_vector <- parApply(cl, as.matrix(mmrf_gene_expr[, -1]), 1, function(x) {
      mod <- glm(response ~ x, family = "binomial")

      # compute pseudo-R^2
      as.numeric(1 - logLik(mod) / logLik(null))
      max(as.numeric(1 - logLik(mod) / logLik(null)), 0)
    })

    pathway_weight_vector <- parApply(cl, as.matrix(pathway_expr[, -1]), 1, function(x) {
      mod <- glm(response ~ x, family = "binomial")

      # compute pseudo-R^2
      as.numeric(1 - logLik(mod) / logLik(null))
      max(as.numeric(1 - logLik(mod) / logLik(null)), 0)
    })
  }
  gene_weights <- cbind(gene_weights, gene_weight_vector)
  pathway_weights <- cbind(pathway_weights, pathway_weight_vector)
}
```

#### MMRF CoMMpass Treatment Variables

```{r load_mmrf_patient_treatment_metadata, eval = !weights_avail}
# load patient treatment metadata
mmrf_treatment <- read_csv(file.path(mmrf_dir, 'clinical_data_tables',
                                     'MMRF_CoMMpass_IA13_STAND_ALONE_TRTRESP.csv'))

# limit metadata to those patients for which gene express data is present and match
# orders
mmrf_treatment <- mmrf_treatment[match(colnames(mmrf_gene_expr)[-1], mmrf_treatment$public_id), ]

# all(mmrf_treatment$public_id == colnames(mmrf_gene_expr)[-1])
# [1] TRUE

# most common treatments

# head(sort(table(mmrf_treatment$trtname), TRUE))
# 
#      Bortezomib/Lenalidomide/Dexamethasone  Bortezomib/Cyclophosphamide/Dexamethasone 
#                                        243                                        138 
#     Carfilzomib/Lenalidomide/Dexamethasone                   Bortezomib/Dexamethasone 
#                                        102                                         73 
#                 Lenalidomide/Dexamethasone Carfilzomib/Cyclophosphamide/Dexamethasone 
#                                         52                                         43 
# 

#treatments <- head(names(sort(table(mmrf_treatment$trtshnm), TRUE)))
#treatments
# [1] "Bor-Len-Dex" "Bor-Cyc-Dex" "Car-Len-Dex" "Bor-Dex"     "Len-Dex"     "Car-Cyc-Dex"

# treatment covariates associated with functional enrichment
treatments <- c('Bor-Len-Dex', 'Bor-Cyc-Dex', 'Bor-Dex', 'Car-Cyc-Dex')

# for each common treatment, build a model predict treatment first response;
for (treatment in treatments) {
  mmrf_treatment_subset <- mmrf_treatment %>%
    filter(trtshnm == treatment) %>%
    select(public_id, first_response = frespcd)

  # in cases where multiple entries for the same id / treatment are present, use the
  # first entry
  mmrf_treatment_subset <- mmrf_treatment_subset %>%
    group_by(public_id) %>%
    slice(1)

  # get rna-seq for samples corresponding to treatment
  expr_mat <- as.matrix(mmrf_gene_expr[, -1])
  expr_mat <- expr_mat[, mmrf_treatment_subset$public_id]

  pathway_mat <- as.matrix(pathway_expr[, -1])
  pathway_mat <- pathway_mat[, mmrf_treatment_subset$public_id]

  # best response also explored, but r^2 for first response generally found to be
  # better.. 
  covariate <- 'first_response'

  message(sprintf("Processing MMRF-IA13 / %s / %s", treatment, covariate))

  # get covariate column
  response <- mmrf_treatment_subset[, covariate, drop = TRUE]

  # column name to use in output
  output_colname <- make.names(sprintf("mmrf_%s_%s", gsub('-', '_', treatment), covariate))
  output_cols <- c(output_cols, output_colname)

  # for factor columns, compute R^2 for a logit predicting the factor level
  if (is.character(response) || length(unique(response)) < 10) {
    response <- factor(response)

    # multinomial logistic regression
    null <- glm(response ~ 1, family = "binomial")

    clusterExport(cl, c('response', 'null'))

    gene_weight_vector <- parApply(cl, expr_mat, 1, function(x) {
      mod <- glm(response ~ x, family = "binomial")
      as.numeric(1 - logLik(mod) / logLik(null))
    })

    pathway_weight_vector <- parApply(cl, pathway_mat, 1, function(x) {
      mod <- glm(response ~ x, family = "binomial")
      as.numeric(1 - logLik(mod) / logLik(null))
    })
  }
  gene_weights <- cbind(gene_weights, gene_weight_vector)
  pathway_weights <- cbind(pathway_weights, pathway_weight_vector)
}
```

#### MMRF CoMMpass Survival Variables

```{r load_mmrf_patient_survival_metadata, eval = !weights_avail}
# load patient survival metadata
# regular and censored overall & progression-free survival
mmrf_surv <- read_csv(file.path(mmrf_dir, 'clinical_data_tables/MMRF_CoMMpass_IA13_STAND_ALONE_SURVIVAL.csv'))

mmrf_surv <- mmrf_surv %>%
  select(public_id, pfsdy, pfscdy, oscdy, censos, censpfs)

# limit metadata to those patients for which gene express data is present and match
# orders
mmrf_surv <- mmrf_surv[match(colnames(mmrf_raw_counts)[-1], mmrf_surv$public_id), ]

#all(mmrf_surv$public_id == colnames(mmrf_raw_counts)[-1])
# [1] TRUE

# Kaplan-Meier survival regression
#fit <- survival::survfit(survival::Surv(pfscdy, censpfs) ~ 1, data = mmrf_surv)
#fit <- survival::survfit(survival::Surv(oscdy, censos) ~ 1, data = mmrf_surv)
#fit <- survival::survfit(survival::Surv(pfscdy, censpfs) ~ 1, data = mmrf_surv)

# Cox regression (survival ~ gene)
clusterExport(cl, c('mmrf_surv'))
tmp_ <- clusterCall(cl, function() library(survival))

# progression-free survival
gene_fits <- parApply(cl, as.matrix(mmrf_gene_expr[, -1]), 1, function(x) {
  summary(survival::coxph(survival::Surv(mmrf_surv$pfscdy, mmrf_surv$censpfs) ~ x))
})

pathway_fits <- parApply(cl, as.matrix(pathway_expr[, -1]), 1, function(x) {
  summary(survival::coxph(survival::Surv(mmrf_surv$pfscdy, mmrf_surv$censpfs) ~ x))
})

# Cox regression Wald statistic
gene_cox_stat <- as.numeric(unlist(lapply(gene_fits, function(x) {
  x$waldtest['test']
})))

pathway_cox_stat <- as.numeric(unlist(lapply(pathway_fits, function(x) {
  x$waldtest['test']
})))

# Cox regression Wald P-value
gene_wald_pvals <- as.numeric(unlist(lapply(gene_fits, function(x) {
  x$waldtest['pvalue']
})))

pathway_wald_pvals <- as.numeric(unlist(lapply(pathway_fits, function(x) {
  x$waldtest['pvalue']
})))

gene_weights <- cbind(gene_weights,
                      mmrf_pfs_cox_stat = gene_cox_stat, mmrf_pfs_cox_pval = gene_wald_pvals)
pathway_weights <- cbind(pathway_weights,
                      mmrf_pfs_cox_stat = pathway_cox_stat, mmrf_pfs_cox_pval = pathway_wald_pvals)
output_cols <- c(output_cols, c('mmrf_pfs_cox_stat', 'mmrf_pfs_cox_pval'))

# overall survival
gene_fits <- parApply(cl, as.matrix(mmrf_gene_expr[, -1]), 1, function(x) {
  summary(survival::coxph(survival::Surv(mmrf_surv$oscdy, mmrf_surv$censos) ~ x))
})

pathway_fits <- parApply(cl, as.matrix(pathway_expr[, -1]), 1, function(x) {
  summary(survival::coxph(survival::Surv(mmrf_surv$oscdy, mmrf_surv$censos) ~ x))
})

# Cox regression Wald statistic
gene_cox_stat <- as.numeric(unlist(lapply(gene_fits, function(x) {
  x$waldtest['test']
})))

pathway_cox_stat <- as.numeric(unlist(lapply(pathway_fits, function(x) {
  x$waldtest['test']
})))

# Cox regression Wald P-value
gene_wald_pvals <- as.numeric(unlist(lapply(gene_fits, function(x) {
  x$waldtest['pvalue']
})))

pathway_wald_pvals <- as.numeric(unlist(lapply(pathway_fits, function(x) {
  x$waldtest['pvalue']
})))

gene_weights <- cbind(gene_weights,
                      mmrf_os_cox_stat = gene_cox_stat, mmrf_os_cox_pval = gene_wald_pvals)
pathway_weights <- cbind(pathway_weights, mmrf_os_cox_stat = pathway_cox_stat,
                         mmrf_os_cox_pval = pathway_wald_pvals)
output_cols <- c(output_cols, c('mmrf_os_cox_stat', 'mmrf_os_cox_pval'))

colnames(gene_weights)[2:ncol(gene_weights)] <- output_cols
colnames(pathway_weights)[2:ncol(pathway_weights)] <- output_cols

# compute gene-, probe-, or pathway-wise distribution statistics
gene_weights$mmrf_mean     <- apply(as.matrix(mmrf_gene_expr[, -1]), 1, mean)
gene_weights$mmrf_median   <- apply(as.matrix(mmrf_gene_expr[, -1]), 1, median)
gene_weights$mmrf_sd       <- apply(as.matrix(mmrf_gene_expr[, -1]), 1, sd)
gene_weights$mmrf_mad      <- apply(as.matrix(mmrf_gene_expr[, -1]), 1, mad)
gene_weights$mmrf_kurtosis <- apply(as.matrix(mmrf_gene_expr[, -1]), 1, kurtosis)

pathway_weights$mmrf_mean     <- apply(as.matrix(pathway_expr[, -1]), 1, mean)
pathway_weights$mmrf_median   <- apply(as.matrix(pathway_expr[, -1]), 1, median)
pathway_weights$mmrf_sd       <- apply(as.matrix(pathway_expr[, -1]), 1, sd)
pathway_weights$mmrf_mad      <- apply(as.matrix(pathway_expr[, -1]), 1, mad)
pathway_weights$mmrf_kurtosis <- apply(as.matrix(pathway_expr[, -1]), 1, kurtosis)

gene_dip <- apply(as.matrix(mmrf_gene_expr[, -1]), 1, dip.test)
gene_weights$mmrf_dip_stat <- unlist(lapply(gene_dip, function(x) { x$statistic }))
gene_weights$mmrf_dip_pval <- unlist(lapply(gene_dip, function(x) { x$p.val }))

pathway_dip <- apply(as.matrix(pathway_expr[, -1]), 1, dip.test)
pathway_weights$mmrf_dip_stat <- unlist(lapply(pathway_dip, function(x) { x$statistic }))
pathway_weights$mmrf_dip_pval <- unlist(lapply(pathway_dip, function(x) { x$p.val }))

# add gene symbols
gene_weights$gene_symbol <- grch37$symbol[match(gene_weights$ensgene, grch37$ensgene)]

# save results
write_csv(gene_weights, gene_weights_path)
write_csv(pathway_weights, pathway_weights_path)
```

```{r mmrf_functional_enrichment, warnings = FALSE, eval = !weights_avail}
# create a dataframe to store enrichment results	
fgsea_res <- NULL

# MMRF covariates to measure enrichment for
cov_cols <- output_cols[!grepl('_cox_stat$', output_cols)]
cov_cols <- c(cov_cols, 'mmrf_dip_pval')

# iterate over covariates and gene sets
for (covariate in cov_cols) {
  message(sprintf("Measuring functional enrichment for %s / MMRF", covariate)) 
  for (gene_set in names(gene_sets)) {
    set.seed(1)

    gene_stats <- setNames(gene_weights %>% pull(covariate), gene_weights$gene_symbol)

    # measure functional enrichment
    res <- fgsea(gene_sets[[gene_set]], gene_stats, nperm = 15000, nproc = MAX_THREADS) %>%
      select(-leadingEdge) %>%
      arrange(padj)

    fgsea_res <- rbind(fgsea_res, cbind(covariate, gene_set, res))
  }
}	

stopCluster(cl)

# clean up
rm(mmrf_expr, mmrf_gene_expr, pathway_expr, mmrf_raw_counts)
suppressMessages(gc())

# store enrichment results
write_csv(fgsea_res, fgsea_path)
```

