### MMRF CoMMpass

```{r process_mmrf_commpass_data}
# mmrf gene weights output filepath
weights_outfile <- file.path(output_dir, 'gene_weights_mmrf.csv')
fgsea_outfile   <- file.path(output_dir, 'fgsea_results_mmrf.csv')
```

```{r load_mmrf_data, eval = !file.exists(weights_outfile)}
# load patient gene expression data
mmrf_raw_counts <- read_tsv(file.path(mmrf_dir, 'rnaseq/MMRF_CoMMpass_IA13a_E74GTF_HtSeq_Gene_Counts.txt.gz'))

# drop non-tumor samples;
mask <- substr(colnames(mmrf_raw_counts), 13, 14) == 'BM'

# first entry is mask corresponds to the patient id column which we always keep
mask[1] <- TRUE
mmrf_raw_counts <- mmrf_raw_counts[, mask]

# remove patients who dropped out?..

# for now, limit ourselves to baseline samples so that we have a single sample collected at the
# same relative stage for each patient
mask <- substr(colnames(mmrf_raw_counts), 11, 14) == '1_BM'
mask[1] <- TRUE

mmrf_raw_counts <- mmrf_raw_counts[, mask]
colnames(mmrf_raw_counts) <- substr(colnames(mmrf_raw_counts), 1, 9)

# drop rna-seq samples with no corresponding sample metadata (lose about 10%
# of patients here who dropped out of the study)
#mask <- substring(colnames(mmrf_raw_counts), 1, 9) %in% mmrf_surv$public_id
#message(sprintf("Excluding %d/%d patient RNA-Seq samples who dropped from study, or are missing metadata", sum(!mask), ncol(mmrf_raw_counts)))
#mmrf_raw_counts <- mmrf_raw_counts[, mask]

# drop "ERCC" rows (92 / 57997 genes)
mask <- !startsWith(mmrf_raw_counts$GENE_ID, 'ERCC')
mmrf_raw_counts <- mmrf_raw_counts[mask, ]

# drop genes with zero variance
mask <- apply(as.matrix(mmrf_raw_counts[, -1]), 1, var) > 0

#table(mask)
# mask
# FALSE  TRUE 
#  2817 55088 

mmrf_raw_counts <- mmrf_raw_counts[mask, ]

# create a cpm-normalized version of the raw counts
mmrf_cpm_counts <- mmrf_raw_counts
mmrf_col_sums <- colSums(mmrf_cpm_counts[, 2:ncol(mmrf_cpm_counts)])
mmrf_cpm_counts[, 2:ncol(mmrf_cpm_counts)] <- sweep(mmrf_cpm_counts[, 2:ncol(mmrf_cpm_counts)],
                                                    2, mmrf_col_sums, '/') * 1E6
```

#### MMRF CoMMpass Clinical Variables

```{r load_mmrf_patient_clinical_metadata, eval = !file.exists(weights_outfile)}
# load patient clinical metadata
mmrf_clin <- read_csv(file.path(mmrf_dir, 'clinical_data_tables',
                                'MMRF_CoMMpass_IA13_PER_PATIENT.csv'))

mmrf_clin <- mmrf_clin %>%
  select(public_id = PUBLIC_ID, iss_stage = R_ISS, ecog, mm_status = D_PT_mmstatus)

# limit metadata to those patients for which gene expression data is present and match
# orders
mmrf_clin <- mmrf_clin[match(colnames(mmrf_raw_counts)[-1], mmrf_clin$public_id), ]

#all(mmrf_clin$public_id == colnames(mmrf_raw_counts)[-1])
# [1] TRUE

# initialize result variable; creates a dataframe with only the gene identifiers
gene_weights <- data.frame(ensgene = mmrf_cpm_counts$GENE_ID)

output_cols <- c()

for (covariate in c('iss_stage', 'ecog', 'mm_status')) {
  message(sprintf("Processing MMRF-IA13 / %s", covariate))

  # get covariate column
  response <- mmrf_clin[, covariate, drop = TRUE]

  # column name to use in output
  output_colname <- make.names(sprintf("mmrf_%s", covariate))
  output_cols <- c(output_cols, output_colname)

  # for factor columns, compute R^2 for a logit predicting the factor level
  if (is.character(response) || length(unique(response)) < 10) {
    response <- factor(response)

    # multinomial logistic regression
    null <- glm(response ~ 1, family = "binomial")

    clusterExport(cl, c('response', 'null'))

    weight_vector <- parApply(cl, as.matrix(mmrf_cpm_counts[, -1]), 1, function(x) {
      mod <- glm(response ~ x, family = "binomial")

      # compute pseudo-R^2
      as.numeric(1 - logLik(mod) / logLik(null))
      max(as.numeric(1 - logLik(mod) / logLik(null)), 0)
    })
  }
  gene_weights <- cbind(gene_weights, weight_vector)
}
```

#### MMRF CoMMpass Treatment Variables

```{r load_mmrf_patient_treatment_metadata, eval = !file.exists(weights_outfile)}
# load patient treatment metadata
mmrf_treatment <- read_csv(file.path(mmrf_dir, 'clinical_data_tables',
                                     'MMRF_CoMMpass_IA13_STAND_ALONE_TRTRESP.csv'))

# limit metadata to those patients for which gene express data is present and match
# orders
mmrf_treatment <- mmrf_treatment[match(colnames(mmrf_cpm_counts)[-1], mmrf_treatment$public_id), ]

# all(mmrf_treatment$public_id == colnames(mmrf_cpm_counts)[-1])
# [1] TRUE

# most common treatments

# head(sort(table(mmrf_treatment$trtname), TRUE))
# 
#      Bortezomib/Lenalidomide/Dexamethasone  Bortezomib/Cyclophosphamide/Dexamethasone 
#                                        243                                        138 
#     Carfilzomib/Lenalidomide/Dexamethasone                   Bortezomib/Dexamethasone 
#                                        102                                         73 
#                 Lenalidomide/Dexamethasone Carfilzomib/Cyclophosphamide/Dexamethasone 
#                                         52                                         43 
# 

treatments <- head(names(sort(table(mmrf_treatment$trtshnm), TRUE)))

# for each common treatment, build a model predict treatment first response;
for (treatment in treatments) {
  mmrf_treatment_subset <- mmrf_treatment %>%
    filter(trtshnm == treatment) %>%
    select(public_id, first_response = frespcd)

  # in cases where multiple entries for the same id / treatment are present, use the
  # first entry
  mmrf_treatment_subset <- mmrf_treatment_subset %>%
    group_by(public_id) %>%
    slice(1)

  # get rna-seq for samples corresponding to treatment
  expr_mat <- as.matrix(mmrf_cpm_counts[, -1])
  expr_mat <- expr_mat[, mmrf_treatment_subset$public_id]

  # best response also explored, but r^2 for first response generally found to be
  # better.. 
  covariate <- 'first_response'

  message(sprintf("Processing MMRF-IA13 / %s / %s", treatment, covariate))

  # get covariate column
  response <- mmrf_treatment_subset[, covariate, drop = TRUE]

  # column name to use in output
  output_colname <- make.names(sprintf("mmrf_%s_%s", gsub('-', '_', treatment), covariate))
  output_cols <- c(output_cols, output_colname)

  # for factor columns, compute R^2 for a logit predicting the factor level
  if (is.character(response) || length(unique(response)) < 10) {
    response <- factor(response)

    # multinomial logistic regression
    null <- glm(response ~ 1, family = "binomial")

    clusterExport(cl, c('response', 'null'))

    weight_vector <- parApply(cl, expr_mat, 1, function(x) {
      mod <- glm(response ~ x, family = "binomial")

      # compute pseudo-R^2
      as.numeric(1 - logLik(mod) / logLik(null))
    })
  }
  gene_weights <- cbind(gene_weights, weight_vector)
}
```

#### MMRF CoMMpass Survival Variables

```{r load_mmrf_patient_survival_metadata, eval = !file.exists(weights_outfile)}
# load patient survival metadata
# regular and censored overall & progression-free survival
mmrf_surv <- read_csv(file.path(mmrf_dir, 'clinical_data_tables/MMRF_CoMMpass_IA13_STAND_ALONE_SURVIVAL.csv'))

mmrf_surv <- mmrf_surv %>%
  select(public_id, pfsdy, pfscdy, oscdy, censos, censpfs)

# limit metadata to those patients for which gene express data is present and match
# orders
mmrf_surv <- mmrf_surv[match(colnames(mmrf_raw_counts)[-1], mmrf_surv$public_id), ]

#all(mmrf_surv$public_id == colnames(mmrf_raw_counts)[-1])
# [1] TRUE

# Kaplan-Meier survival regression
#fit <- survival::survfit(survival::Surv(pfscdy, censpfs) ~ 1, data = mmrf_surv)
#fit <- survival::survfit(survival::Surv(oscdy, censos) ~ 1, data = mmrf_surv)
#fit <- survival::survfit(survival::Surv(pfscdy, censpfs) ~ 1, data = mmrf_surv)

# Cox regression (survival ~ gene)
clusterExport(cl, c('mmrf_surv'))
tmp_ <- clusterCall(cl, function() library(survival))

# progression-free survival
fits <- parApply(cl, as.matrix(mmrf_cpm_counts[, -1]), 1, function(x) {
  summary(survival::coxph(survival::Surv(mmrf_surv$pfscdy, mmrf_surv$censpfs) ~ x))
})

# Cox regression Wald statistic
cox_stat <- as.numeric(unlist(lapply(fits, function(x) {
  x$waldtest['test']
})))

# Cox regression Wald P-value
wald_pvals <- as.numeric(unlist(lapply(fits, function(x) {
  x$waldtest['pvalue']
})))

gene_weights <- cbind(gene_weights,
                      mmrf_pfs_cox_stat = cox_stat, mmrf_pfs_cox_pval = wald_pvals)
output_cols <- c(output_cols, c('mmrf_pfs_cox_stat', 'mmrf_pfs_cox_pval'))

# overall survival
fits <- parApply(cl, as.matrix(mmrf_cpm_counts[, -1]), 1, function(x) {
  summary(survival::coxph(survival::Surv(mmrf_surv$oscdy, mmrf_surv$censos) ~ x))
})

# Cox regression Wald statistic
cox_stat <- as.numeric(unlist(lapply(fits, function(x) {
  x$waldtest['test']
})))

# Cox regression Wald P-value
wald_pvals <- as.numeric(unlist(lapply(fits, function(x) {
  x$waldtest['pvalue']
})))

gene_weights <- cbind(gene_weights,
                      mmrf_os_cox_stat = cox_stat, mmrf_os_cox_pval = wald_pvals)
output_cols <- c(output_cols, c('mmrf_os_cox_stat', 'mmrf_os_cox_pval'))

colnames(gene_weights)[2:ncol(gene_weights)] <- output_cols

# compute gene- or probe-wise distribution statistics
gene_weights$mmrf_mean     <- apply(as.matrix(mmrf_cpm_counts[, -1]), 1, mean)
gene_weights$mmrf_median   <- apply(as.matrix(mmrf_cpm_counts[, -1]), 1, median)
gene_weights$mmrf_sd       <- apply(as.matrix(mmrf_cpm_counts[, -1]), 1, sd)
gene_weights$mmrf_mad      <- apply(as.matrix(mmrf_cpm_counts[, -1]), 1, mad)
gene_weights$mmrf_kurtosis <- apply(as.matrix(mmrf_cpm_counts[, -1]), 1, kurtosis)

dip <- apply(as.matrix(mmrf_cpm_counts[, -1]), 1, dip.test)
gene_weights$mmrf_dip_stat <- unlist(lapply(dip, function(x) { x$statistic }))
gene_weights$mmrf_dip_pval <- unlist(lapply(dip, function(x) { x$p.val }))

# add gene symbols
gene_weights$gene_symbol <- grch37$symbol[match(gene_weights$ensgene, grch37$ensgene)]

# save results
write_csv(gene_weights, weights_outfile)
```

```{r mmrf_functional_enrichment, warnings = FALSE, eval = !file.exists(fgsea_outfile)}
# create a dataframe to store enrichment results	
fgsea_res <- NULL

# MMRF covariates to measure enrichment for
cov_cols <- output_cols[!grepl('_cox_stat$', output_cols)]
cov_cols <- c(cov_cols, 'mmrf_dip_pval')

# iterate over covariates and gene sets
for (covariate in cov_cols) {
  message(sprintf("Measuring functional enrichment for %s / MMRF", covariate)) 
  for (gene_set in names(gene_sets)) {
    set.seed(1)

    gene_stats <- setNames(gene_weights %>% pull(covariate), gene_weights$gene_symbol)

    # measure functional enrichment
    res <- fgsea(gene_sets[[gene_set]], gene_stats, nperm = 15000, nproc = MAX_THREADS) %>%
      filter(padj < 0.05) %>%
      select(-leadingEdge) %>%
      arrange(padj)

    if (nrow(res) > 0) {
      fgsea_res <- rbind(fgsea_res, cbind(covariate, gene_set, res))
    }
  }
}	

# store enrichment results
if (!is.null(fgsea_res)) {
  write_csv(fgsea_res, fgsea_outfile)
}
```

