### GEO

```{r parse_geo_datasets, message = FALSE, warning = FALSE}
# iterate over datasets and measure gene / phenotype correlation
accessions <- list.files(geo_dir)

#
# datasets with no relevant covariate data available (used just for sd, etc.
# gene-level stats)
#
# GSE31161
# GSE7039
#

# list of factor covariates to process for each accession;
# logistic regression models will be built for each such variable
factor_covariates <- list(
  "GSE116324" = c('treatment_response'),
  "GSE118900" = c('mm_stage'),
  "GSE19784"  = c('iss_stage', 'patient_subgroup'),
  "GSE2113"   = c('mm_stage'),
  "GSE24080"  = c('pfs_event', 'patient_died'),
  "GSE2658"   = c('patient_died', 'patient_subgroup'),
  "GSE2912"   = c('mm_stage'),
  "GSE47552"  = c('mm_stage'),
  "GSE57317"  = c('patient_subgroup'),
  "GSE6477"   = c('mm_stage'),
  "GSE68871"  = c('treatment_response'),
  "GSE7039"   = c('patient_died'),
  "GSE83503"  = c('patient_died', 'pfs_event'),
  "GSE9782"   = c('treatment_response', 'patient_subgroup')
)

# survival-related covariates;
# cox regression models will be constructed for each variable or pair of variables
survival_covariates <- list(
  "GSE19784" = list('os'  = c('os_time', 'os_event'),
                    'pfs' = c('pfs_time', 'pfs_event')),
  "GSE9782"  = list('os'  = c('os_time', 'patient_died'),
                    'pfs' = c('pfs_time', 'pfs_event')),
  "GSE7039"  = list('os'  = c('os_time', 'patient_died')),
  "GSE57317" = list('os'  = c('os_time', 'os_event'))
)

for (acc in accessions) {
  # load gene expression data
  data_dir <- file.path(geo_dir, acc, 'processed')

  message(sprintf("Processing dataset %s", acc))

  # filenames
  expr_infile <- file.path(data_dir, sprintf("%s_expr.csv", acc))
  mdat_infile <- file.path(data_dir, sprintf("%s_sample_metadata.csv", acc))

  weights_outfile <- file.path(output_dir, sprintf('gene_weights_%s.csv', acc))
  fgsea_outfile   <- file.path(output_dir, sprintf('fgsea_results_%s.csv', acc))

  # if the gene weights have already been computed, load from file and continue
	if (file.exists(weights_outfile)) {
		message(sprintf("Skipping %s; output already exists...", acc))
		next
	}

  # if data is missing, skip
  if (!file.exists(expr_infile)) {
		message(sprintf("Skipping %s; data unavailable...", acc))
		next
  }

  # otherwise load gene expression data and sample metadata and compute weights
  expr <- read_csv(expr_infile)

	# exclude any entries which couldn't be mapped to any gene symbols
	expr <- expr[!is.na(expr$gene_symbol), ]	

  # sample column indices
  ID_COLS <- c('probe_id', 'gene_symbol', 'ensgene')
	sample_ind <- !colnames(expr) %in% ID_COLS

  # create a version without the gene / probe identifiers
  expr_mat <- as.matrix(expr[, sample_ind])

  # load sample metadata
  mdat <- read.csv(mdat_infile)

  # initialize result variable; creates a dataframe with only the gene identifiers
  gene_weights <- expr[, !sample_ind, drop = FALSE]

  # measure correlation or R^2 between each gene and each factor covariate
  if (acc %in% names(factor_covariates)) {
    # keep track of column names to use for output
    output_cols <- c()

    for (covariate in factor_covariates[[acc]]) {
      message(sprintf("Processing %s / %s", acc, covariate))

      # get covariate column
      response <- mdat[, covariate]

      # column name to use in output
      output_colname <- make.names(sprintf("%s_%s", acc, covariate))
      output_cols <- c(output_cols, output_colname)

      # for factor columns, compute R^2 for a logit predicting the factor level
      if (is.character(response) || length(unique(response)) < 10) {
        response <- factor(response)

        # multinomial logistic regression
        null <- glm(response ~ 1, family="binomial")

        clusterExport(cl, c('response', 'null'))

        weight_vector <- parApply(cl, expr_mat, 1, function(x) {
          mod <- glm(response ~ x, family = "binomial")

          # compute pseudo-R^2
          max(as.numeric(1 - logLik(mod) / logLik(null)), 0)
        })
      }
      gene_weights <- cbind(gene_weights, weight_vector)
    }

    # fix column and row names and save to disk
    colnames(gene_weights)[(sum(!sample_ind) + 1):ncol(gene_weights)] <- output_cols
  }

  # next, for those datasets with survival-related covariates, build cox regression
  # models
  if (acc %in% names(survival_covariates)) {
    clusterExport(cl, c('mdat'))
    tmp_ <- clusterCall(cl, function() library(survival))

    for (survival_covariate_name in names(survival_covariates[[acc]])) {
      message(sprintf("Processing %s / %s", acc, survival_covariate_name))

      surv_cov <- survival_covariates[[acc]][[survival_covariate_name]]

      clusterExport(cl, c('surv_cov'))

      # survival duration + censor/event
      #if (length(surv_cov) == 2) {

      fits <- parApply(cl, expr_mat, 1, function(x) {
        surv <- survival::Surv(time = mdat[, surv_cov[1]], event = mdat[, surv_cov[2]])
        summary(survival::coxph(surv ~ x))
      })

      #} else {
      #  # survival duration only
      #  fits <- parApply(cl, expr_mat, 1, function(x) {
      #    surv <- survival::Surv(time = mdat[, surv_cov[1]])
      #    summary(survival::coxph(surv ~ x))
      #  })
      #}

      # cox regression Wald statistic
      cox_stat <- as.numeric(unlist(lapply(fits, function(x) {
        x$waldtest['test']
      })))

      # cox regression Wald P-value
      cox_pval <- as.numeric(unlist(lapply(fits, function(x) {
        x$waldtest['pvalue']
      })))

      # add to gene weights and fix column names
      gene_weights <- cbind(gene_weights, cox_stat, cox_pval)

      cnames <- paste(acc, survival_covariate_name, c('cox_stat', 'cox_pval'), sep = '_')
      colnames(gene_weights)[(ncol(gene_weights) - 1):ncol(gene_weights)] <- cnames
    }
  }

  # compute gene- or probe-wise distribution statistics
  gene_weights$mean     <- apply(expr_mat, 1, mean)
  gene_weights$median   <- apply(expr_mat, 1, median)
  gene_weights$sd       <- apply(expr_mat, 1, sd)
  gene_weights$mad      <- apply(expr_mat, 1, mad)
  gene_weights$kurtosis <- apply(expr_mat, 1, kurtosis)

  # dip test
  dip <- apply(expr_mat, 1, dip.test)
  gene_weights$dip_stat <- unlist(lapply(dip, function(x) { x$statistic }))
  gene_weights$dip_pval <- unlist(lapply(dip, function(x) { x$p.val }))

  # prepend dataset accession to column names
  ind <- colnames(gene_weights) %in% c('mean', 'median', 'sd', 'mad', 'kurtosis', 'dip_stat', 'dip_pval')
  colnames(gene_weights)[ind] <- paste0(acc, '_', colnames(gene_weights)[ind])

	# covariate column names
	pval_cols  <- colnames(gene_weights)[endsWith(colnames(gene_weights), 'pval')]
	other_cols <- colnames(gene_weights)[startsWith(colnames(gene_weights), 'GSE') &
  																		 !endsWith(colnames(gene_weights), 'pval')]

	# for each gene that mapped to multiple probes, keep the most significant results;
	# i.e. keep the maximum values for each non- p-value column and the minimum
  # values for each p-value column
	if ('probe_id' %in% colnames(gene_weights)) {
		gene_weights <- gene_weights %>%
			separate_rows(gene_symbol, sep = " ?/+ ?") %>%
			group_by(gene_symbol) %>%
			mutate_at(vars(other_cols), max) %>%
			group_by_at(vars(other_cols), .add = TRUE) %>%
			summarise_at(vars(pval_cols), min)
	} else if ('ensgene' %in% colnames(gene_weights)) {
		# for datasets with ensgenes + gene symbols, perform a similar summarization
		# without the probe_id splitting step
		gene_weights <- gene_weights %>%
			group_by(gene_symbol) %>%
			mutate_at(vars(other_cols), max) %>%
			group_by_at(vars(other_cols), .add = TRUE) %>%
			summarise_at(vars(pval_cols), min)
	}

	# store gene weights
  write_csv(gene_weights, weights_outfile)

	# create a dataframe to store enrichment results	
	fgsea_res <- NULL

	if (acc %in% names(factor_covariates)) {
		# get updated column names
		cov_cols <- sprintf('%s_%s', acc, factor_covariates[[acc]])

		# iterate over covariates and gene sets
		for (covariate in cov_cols) {
			message(sprintf("Measuring functional enrichment for %s / %s", covariate, acc)) 
			for (gene_set in names(gene_sets)) {
				set.seed(1)

				gene_stats <- setNames(gene_weights %>% pull(covariate), gene_weights$gene_symbol)

				# measure functional enrichment
				res <- fgsea(gene_sets[[gene_set]], gene_stats, nperm = 15000, nproc = MAX_THREADS) %>%
					select(-leadingEdge) %>%
					arrange(padj)

        fgsea_res <- rbind(fgsea_res, cbind(covariate, gene_set, res))
			}
		}	
	}	

	# functional enrichment for p-value columns
	cov_cols <- colnames(gene_weights)[endsWith(colnames(gene_weights), '_pval')]

	# iterate over covariates and gene sets
	for (covariate in cov_cols) {
		message(sprintf("Measuring functional enrichment for %s / %s", covariate, acc)) 
		for (gene_set in names(gene_sets)) {
			set.seed(1)

			gene_stats <- setNames(gene_weights %>% pull(covariate), gene_weights$gene_symbol)
			
			# measure functional enrichment
			res <- fgsea(gene_sets[[gene_set]], gene_stats, nperm = 15000, nproc = MAX_THREADS) %>%
				select(-leadingEdge) %>%
				arrange(padj)

      fgsea_res <- rbind(fgsea_res, cbind(covariate, gene_set, res))
		}
	}	

	# store enrichment results
  write_csv(fgsea_res, fgsea_outfile)
}
```

